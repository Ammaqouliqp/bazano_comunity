# products.py
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    CommandHandler, CallbackQueryHandler, ConversationHandler,
    MessageHandler, ContextTypes, filters
)
from db import cursor, conn
from logs import add_log
from auth import sessions

# states
(ADD_BRAND, ADD_NAME, ADD_DESC, ADD_MDATE, ADD_EDATE, ADD_QTY, ADD_PRICE_ENTRY, ADD_PRICE_EXIT) = range(8)
(EDIT_SELECT, EDIT_VALUE) = range(100, 102)
PAGE_SIZE = 8

def get_user(tg_id):
    phone = sessions.get(tg_id)
    if not phone:
        return None
    cursor.execute("SELECT id, firstname, lastname, role FROM users WHERE phonenumber=?", (phone,))
    return cursor.fetchone()

# products menu
async def products_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # support command or callback
    if update.callback_query:
        await update.callback_query.answer()
        target = update.callback_query.message
    else:
        target = update.message

    user = get_user(update.effective_user.id)
    if not user:
        await target.reply_text("‚ö†Ô∏è ŸÑÿ∑ŸÅÿßŸã ÿßÿ®ÿ™ÿØÿß /start ⁄©ŸÜ€åÿØ Ÿà Ÿàÿßÿ±ÿØ ÿ¥Ÿà€åÿØ.")
        return

    kb = [
        [InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ŸÖÿ≠ÿµŸàŸÑ", callback_data="products:add")],
        [InlineKeyboardButton("üìã ŸÑ€åÿ≥ÿ™ ŸÖÿ≠ÿµŸàŸÑÿßÿ™", callback_data="products:list:0")],
        [InlineKeyboardButton("‚ùå ÿ®ÿ≥ÿ™ŸÜ", callback_data="products:close")]
    ]
    await target.reply_text("üì¶ ŸÖŸÜŸà€å ŸÖÿ≠ÿµŸàŸÑÿßÿ™:", reply_markup=InlineKeyboardMarkup(kb))

# add product conv
async def add_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.callback_query:
        await update.callback_query.answer()
        await update.callback_query.message.reply_text("‚ûï ÿ¥ÿ±Ÿàÿπ ÿßŸÅÿ≤ŸàÿØŸÜ ŸÖÿ≠ÿµŸàŸÑ (ÿ®ÿ±ÿß€å ŸÑÿ∫Ÿà /cancel):")
    else:
        await update.message.reply_text("‚ûï ÿ¥ÿ±Ÿàÿπ ÿßŸÅÿ≤ŸàÿØŸÜ ŸÖÿ≠ÿµŸàŸÑ (ÿ®ÿ±ÿß€å ŸÑÿ∫Ÿà /cancel):")
    user = get_user(update.effective_user.id)
    if not user:
        await update.message.reply_text("‚ö†Ô∏è ÿßÿ®ÿ™ÿØÿß Ÿàÿßÿ±ÿØ ÿ¥Ÿà€åÿØ.")
        return ConversationHandler.END
    context.user_data['actor'] = user
    await update.effective_chat.send_message("üè∑ ÿ®ÿ±ŸÜÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:")
    return ADD_BRAND

async def add_brand(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['brand'] = update.message.text.strip()
    await update.message.reply_text("üìõ ŸÜÿßŸÖ ŸÖÿ≠ÿµŸàŸÑ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:")
    return ADD_NAME

async def add_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['name'] = update.message.text.strip()
    await update.message.reply_text("üìù ÿ™Ÿàÿ∂€åÿ≠ÿßÿ™ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ €åÿß 'no':")
    return ADD_DESC

async def add_desc(update: Update, context: ContextTypes.DEFAULT_TYPE):
    txt = update.message.text.strip()
    context.user_data['description'] = None if txt.lower() in ("no", "-", "") else txt
    await update.message.reply_text("üè≠ ÿ™ÿßÿ±€åÿÆ ÿ™ŸàŸÑ€åÿØ (YYYY-MM-DD) €åÿß 'no':")
    return ADD_MDATE

async def add_mdate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    txt = update.message.text.strip()
    context.user_data['manufacture_date'] = None if txt.lower() in ("no", "-", "") else txt
    await update.message.reply_text("‚åõ ÿ™ÿßÿ±€åÿÆ ÿßŸÜŸÇÿ∂ÿß (YYYY-MM-DD) €åÿß 'no':")
    return ADD_EDATE

async def add_edate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    txt = update.message.text.strip()
    context.user_data['expire_date'] = None if txt.lower() in ("no", "-", "") else txt
    await update.message.reply_text("‚öñÔ∏è ŸÖŸÇÿØÿßÿ± + Ÿàÿßÿ≠ÿØ (ŸÖÿ´ÿßŸÑ: 5 kg):")
    return ADD_QTY

async def add_qty(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['quantity'] = update.message.text.strip()
    role = context.user_data['actor'][3]  # role
    if role == "seller":
        await update.message.reply_text("üíµ ŸÇ€åŸÖÿ™ Ÿàÿ±ŸàÿØ (ÿß€åŸÜ ŸÇ€åŸÖÿ™ Ÿàÿ±ŸàÿØ ⁄©ÿßŸÑÿß€å ÿ¥ŸÖÿß ÿ®Ÿá ÿ®ÿßÿ≤ÿßŸÜŸà ÿßÿ≥ÿ™). ŸÑÿ∑ŸÅÿßŸã ÿπÿØÿØ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:")
    else:
        await update.message.reply_text("üíµ ŸÇ€åŸÖÿ™ Ÿàÿ±ŸàÿØ (ÿß€åŸÜ ŸÇ€åŸÖÿ™ÿå ŸÇ€åŸÖÿ™ Ÿàÿ±ŸàÿØ ÿ®Ÿá ÿ®ÿßÿ≤ÿßŸÜŸà ÿßÿ≥ÿ™). ŸÑÿ∑ŸÅÿßŸã ŸÇ€åŸÖÿ™ Ÿàÿßÿ≠ÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:")
    return ADD_PRICE_ENTRY

async def add_price_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        val = float(update.message.text.strip())
    except:
        await update.message.reply_text("‚ö†Ô∏è ŸÖŸÇÿØÿßÿ± ŸÜÿßŸÖÿπÿ™ÿ®ÿ±ÿå ÿπÿØÿØ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:")
        return ADD_PRICE_ENTRY
    context.user_data['price_entry'] = val
    role = context.user_data['actor'][3]
    if role in ("admin", "manager"):
        await update.message.reply_text("üí∞ (ÿßÿÆÿ™€åÿßÿ±€å) ŸÇ€åŸÖÿ™ ÿÆÿ±Ÿàÿ¨ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ €åÿß 'no':")
        return ADD_PRICE_EXIT
    # seller path
    context.user_data['price_exit'] = None
    # save
    return await add_save(update, context)

async def add_price_exit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    txt = update.message.text.strip().lower()
    if txt in ("no", "-", ""):
        context.user_data['price_exit'] = None
    else:
        try:
            context.user_data['price_exit'] = float(txt)
        except:
            await update.message.reply_text("‚ö†Ô∏è ŸÖŸÇÿØÿßÿ± ŸÜÿßŸÖÿπÿ™ÿ®ÿ±ÿå ÿπÿØÿØ €åÿß 'no' Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:")
            return ADD_PRICE_EXIT
    return await add_save(update, context)

async def add_save(update: Update, context: ContextTypes.DEFAULT_TYPE):
    actor = context.user_data['actor']
    user_id = actor[0]
    cursor.execute("""
        INSERT INTO products (brand, name, description, manufacture_date, expire_date, quantity, price_entry, price_exit, created_by, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
    """, (
        context.user_data.get('brand'),
        context.user_data.get('name'),
        context.user_data.get('description'),
        context.user_data.get('manufacture_date'),
        context.user_data.get('expire_date'),
        context.user_data.get('quantity'),
        context.user_data.get('price_entry'),
        context.user_data.get('price_exit'),
        user_id
    ))
    conn.commit()
    pid = cursor.lastrowid
    add_log(user_id, "ADD_PRODUCT", f"product_id={pid} name={context.user_data.get('name')}")
    await update.message.reply_text(f"‚úÖ ŸÖÿ≠ÿµŸàŸÑ ÿ´ÿ®ÿ™ ÿ¥ÿØ (ID={pid}).", reply_markup=ReplyKeyboardRemove())
    return ConversationHandler.END

# list products (paginated)
async def list_products_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    cq = update.callback_query
    await cq.answer()
    parts = cq.data.split(":")
    page = int(parts[2])
    await send_products_list(cq.message, cq.from_user.id, page)

async def send_products_list(message, tg_id, page=0):
    user = get_user(tg_id)
    if not user:
        await message.reply_text("‚ö†Ô∏è ÿßÿ®ÿ™ÿØÿß Ÿàÿßÿ±ÿØ ÿ¥Ÿà€åÿØ.")
        return
    role = user[3]
    offset = page * PAGE_SIZE
    cursor.execute("SELECT id, brand, name, quantity, price_entry, price_exit, created_by FROM products ORDER BY id DESC LIMIT ? OFFSET ?", (PAGE_SIZE, offset))
    rows = cursor.fetchall()
    if not rows:
        await message.reply_text("üì≠ Ÿá€å⁄Ü ŸÖÿ≠ÿµŸàŸÑ€å ÿ®ÿ±ÿß€å ŸÜŸÖÿß€åÿ¥ Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.")
        return
    lines = []
    kb = []
    for r in rows:
        lines.append(f"#{r[0]} ‚Äî {r[1]} | {r[2]} ({r[3]})")
        kb.append([InlineKeyboardButton(f"ŸÜŸÖÿß€åÿ¥ #{r[0]}", callback_data=f"products:view:{r[0]}")])
    # pagination nav
    cursor.execute("SELECT COUNT(*) FROM products")
    total = cursor.fetchone()[0]
    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton("‚¨ÖÔ∏è ŸÇÿ®ŸÑ€å", callback_data=f"products:list:{page-1}"))
    if (page+1)*PAGE_SIZE < total:
        nav.append(InlineKeyboardButton("ÿ®ÿπÿØ€å ‚û°Ô∏è", callback_data=f"products:list:{page+1}"))
    if nav:
        kb.append(nav)
    kb.append([InlineKeyboardButton("üîô ÿ®ÿ≥ÿ™ŸÜ", callback_data="products:close")])
    await message.reply_text("üìã ŸÑ€åÿ≥ÿ™ ŸÖÿ≠ÿµŸàŸÑÿßÿ™:\n\n" + "\n".join(lines), reply_markup=InlineKeyboardMarkup(kb))

# view product
async def view_product_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    cq = update.callback_query
    await cq.answer()
    parts = cq.data.split(":")
    pid = int(parts[2])
    cursor.execute("SELECT id, brand, name, description, manufacture_date, expire_date, quantity, price_entry, price_exit, created_by FROM products WHERE id=?", (pid,))
    r = cursor.fetchone()
    if not r:
        await cq.message.reply_text("‚ö†Ô∏è ŸÖÿ≠ÿµŸàŸÑ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
        return
    user = get_user(cq.from_user.id)
    role = user[3] if user else None
    text = f"üì¶ #{r[0]} ‚Äî {r[1]} | {r[2]}\n\nüìù {r[3] or '-'}\nüè≠ ÿ™ŸàŸÑ€åÿØ: {r[4] or '-'}\n‚åõ ÿßŸÜŸÇÿ∂ÿß: {r[5] or '-'}\n‚öñÔ∏è ŸÖŸÇÿØÿßÿ±: {r[6]}\nüíµ ŸÇ€åŸÖÿ™ Ÿàÿ±ŸàÿØ: {r[7]}\n"
    if role in ("admin","manager"):
        text += f"üí∞ ŸÇ€åŸÖÿ™ ÿÆÿ±Ÿàÿ¨: {r[8] or '-'}\n"
    else:
        text += "üîî ŸÇ€åŸÖÿ™ ÿÆÿ±Ÿàÿ¨ ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å ŸÖÿØ€åÿ±/ÿßÿØŸÖ€åŸÜ ŸÇÿßÿ®ŸÑ ŸÖÿ¥ÿßŸáÿØŸá ÿßÿ≥ÿ™.\n"
    kb = [
        [InlineKeyboardButton("‚úèÔ∏è Ÿà€åÿ±ÿß€åÿ¥", callback_data=f"products:edit:{pid}"),
         InlineKeyboardButton("üóë ÿ≠ÿ∞ŸÅ", callback_data=f"products:del:{pid}")],
        [InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data="products:list:0")]
    ]
    await cq.message.reply_text(text, reply_markup=InlineKeyboardMarkup(kb))
    add_log(user[0] if user else None, "VIEW_PRODUCT", f"product_id={pid}")

# delete product confirm
async def del_product_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    cq = update.callback_query
    await cq.answer()
    pid = int(cq.data.split(":")[2])
    kb = [
        [InlineKeyboardButton("‚úÖ ÿ™ÿß€å€åÿØ ÿ≠ÿ∞ŸÅ", callback_data=f"products:del_confirm:{pid}")],
        [InlineKeyboardButton("‚ùå ÿßŸÜÿµÿ±ÿßŸÅ", callback_data=f"products:view:{pid}")]
    ]
    await cq.message.reply_text(f"‚ö†Ô∏è ÿ¢€åÿß ÿßÿ≤ ÿ≠ÿ∞ŸÅ ŸÖÿ≠ÿµŸàŸÑ #{pid} ÿßÿ∑ŸÖ€åŸÜÿßŸÜ ÿØÿßÿ±€åÿØÿü", reply_markup=InlineKeyboardMarkup(kb))

async def del_confirm_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    cq = update.callback_query
    await cq.answer()
    pid = int(cq.data.split(":")[2])
    user = get_user(cq.from_user.id)
    uid = user[0] if user else None
    cursor.execute("DELETE FROM products WHERE id=?", (pid,))
    conn.commit()
    add_log(uid, "DELETE_PRODUCT", f"product_id={pid}")
    await cq.message.reply_text(f"üóë ŸÖÿ≠ÿµŸàŸÑ #{pid} ÿ≠ÿ∞ŸÅ ÿ¥ÿØ.")

# edit product: entry -> show fields -> accept new value
async def edit_entry_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    cq = update.callback_query
    await cq.answer()
    pid = int(cq.data.split(":")[2])
    context.user_data['edit_pid'] = pid
    user = get_user(cq.from_user.id)
    role = user[3] if user else None
    kb = [
        [InlineKeyboardButton("ÿ®ÿ±ŸÜÿØ", callback_data=f"products:edit_field:brand:{pid}"),
         InlineKeyboardButton("ŸÜÿßŸÖ", callback_data=f"products:edit_field:name:{pid}")],
        [InlineKeyboardButton("ÿ™Ÿàÿ∂€åÿ≠ÿßÿ™", callback_data=f"products:edit_field:description:{pid}"),
         InlineKeyboardButton("ÿ™ÿßÿ±€åÿÆ ÿ™ŸàŸÑ€åÿØ", callback_data=f"products:edit_field:manufacture_date:{pid}")],
        [InlineKeyboardButton("ÿ™ÿßÿ±€åÿÆ ÿßŸÜŸÇÿ∂ÿß", callback_data=f"products:edit_field:expire_date:{pid}"),
         InlineKeyboardButton("ŸÖŸÇÿØÿßÿ±", callback_data=f"products:edit_field:quantity:{pid}")],
        [InlineKeyboardButton("ŸÇ€åŸÖÿ™ Ÿàÿ±ŸàÿØ", callback_data=f"products:edit_field:price_entry:{pid}")]
    ]
    if role in ("admin","manager"):
        kb[-1].append(InlineKeyboardButton("ŸÇ€åŸÖÿ™ ÿÆÿ±Ÿàÿ¨", callback_data=f"products:edit_field:price_exit:{pid}"))
    kb.append([InlineKeyboardButton("‚úÖ ÿßÿ™ŸÖÿßŸÖ / ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=f"products:view:{pid}")])
    await cq.message.reply_text("üîß ŸÅ€åŸÑÿØ ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:", reply_markup=InlineKeyboardMarkup(kb))
    return EDIT_SELECT

async def edit_field_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    cq = update.callback_query
    await cq.answer()
    parts = cq.data.split(":")
    field = parts[3]
    pid = int(parts[4])
    context.user_data['edit_field'] = field
    await cq.message.reply_text(f"‚úçÔ∏è ŸÖŸÇÿØÿßÿ± ÿ¨ÿØ€åÿØ ÿ®ÿ±ÿß€å `{field}` ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ:", parse_mode="Markdown")
    return EDIT_VALUE

async def edit_value_received(update: Update, context: ContextTypes.DEFAULT_TYPE):
    field = context.user_data.get('edit_field')
    pid = context.user_data.get('edit_pid')
    user = get_user(update.effective_user.id)
    uid = user[0] if user else None
    if not field or not pid:
        await update.message.reply_text("‚ö†Ô∏è ÿÆÿ∑ÿß ÿØÿ± ÿßÿ∑ŸÑÿßÿπÿßÿ™ Ÿà€åÿ±ÿß€åÿ¥.")
        return ConversationHandler.END
    new = update.message.text.strip()
    if field in ("price_entry", "price_exit"):
        try:
            newd = float(new)
        except:
            await update.message.reply_text("‚ö†Ô∏è ŸÖŸÇÿØÿßÿ± ŸÜÿßŸÖÿπÿ™ÿ®ÿ±. ÿßÿ≤ ÿπÿØÿØ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.")
            return EDIT_VALUE
    else:
        newd = new
    cursor.execute(f"UPDATE products SET {field}=? WHERE id=?", (newd, pid))
    conn.commit()
    add_log(uid, "EDIT_PRODUCT", f"product_id={pid} field={field}")
    await update.message.reply_text("‚úÖ ŸÖŸÇÿØÿßÿ± ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ÿØ.")
    return ConversationHandler.END

# close products
async def products_close_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.callback_query:
        await update.callback_query.answer()
        try:
            await update.callback_query.message.delete()
        except:
            pass

def get_product_handlers():
    handlers = []
    handlers.append(CommandHandler("products_menu", products_menu))
    handlers.append(CallbackQueryHandler(products_menu, pattern="^products_menu$"))
    # add conversation
    add_conv = ConversationHandler(
        entry_points=[CommandHandler("add_product", add_start), CallbackQueryHandler(add_start, pattern="^products:add$")],
        states={
            ADD_BRAND: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_brand)],
            ADD_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_name)],
            ADD_DESC: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_desc)],
            ADD_MDATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_mdate)],
            ADD_EDATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_edate)],
            ADD_QTY: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_qty)],
            ADD_PRICE_ENTRY: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_price_entry)],
            ADD_PRICE_EXIT: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_price_exit)],
        },
        fallbacks=[CommandHandler("cancel", lambda u,c: (c.user_data.clear(), ReplyKeyboardRemove()))],
        allow_reentry=True
    )
    handlers.append(add_conv)
    # list
    handlers.append(CallbackQueryHandler(list_products_cb, pattern="^products:list:\d+$"))
    handlers.append(CallbackQueryHandler(view_product_cb, pattern="^products:view:\d+$"))
    handlers.append(CallbackQueryHandler(del_product_cb, pattern="^products:del:\d+$"))
    handlers.append(CallbackQueryHandler(del_confirm_cb, pattern="^products:del_confirm:\d+$"))
    # edit conversation
    edit_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(edit_entry_cb, pattern="^products:edit:\d+$")],
        states={
            EDIT_SELECT: [CallbackQueryHandler(edit_field_cb, pattern="^products:edit_field:")],
            EDIT_VALUE: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_value_received)]
        },
        fallbacks=[CommandHandler("cancel", lambda u,c: (c.user_data.clear(), ReplyKeyboardRemove()))],
        allow_reentry=True
    )
    handlers.append(edit_conv)
    handlers.append(CallbackQueryHandler(products_close_cb, pattern="^products:close$"))
    return handlers
